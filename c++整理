面向对象（OOP）：
1.特征，封装，继承，多态
2.封装，把客观事物封装成抽象的类；
3.public： 该类的成员函数和成员变量可被本类以及子类以及孙子类调用外，也被类的对象调用；
4.protected： 该类的成员函数和成员变量可被本类和子类调用外，不可被类对象调用；
5.private;：该类的成员函数和成员变量只能在本类中调用，不可为子类以及类对象调用；

继承：
1. 父类---（public，protect，private继承）--->子类;
2.public继承后基类中的public仍为public，基类中的protected仍为protected，基类中的private仍为private；
3.protected继承后基类中public属性变为protected，基类中的protected仍为protected，基类中的private仍为private；
4.private继承后基类中的public，protected变为private，基类中的private仍为private；

多态：
1.重载多态（编译期），函数重载、运算符重载；
2.子类型多态（运行期），虚函数；
3.参数多态性（编译期），类模板、函数模板；
4.强制多态（编译期/运行期），基本类型转换、自定义类型转换；
5.俗话说的编译时动态就是重载，运行时动态就是通过子类继承父类的虚函数实现的多态，通过调用函数类型确定调用那个成员函数；
6.调用时多态基类的析构函数要定义为虚函数，防止内存泄漏，调用顺序为，先调用子类析构函数再调用基类析构函数；

虚函数：
1.普通函数（非类成员函数）不能是虚函数；
2.静态函数（static）不能是虚函数；
3.构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）；
4.内联函数不能是实现多态性时的虚函数；
5.虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象；
6.纯虚函数是一种为了实现接口的特殊虚函数，只能在子类中实现；


虚函数和纯虚函数的区别：
1.虚函数可以在基类中实现，也可以在子类中实现，纯虚函数只能在子类中实现；
2.虚函数在继承时完全继承虚函数的实现，纯虚函数在继承时，子类只是继承了一个接口定义；
3.虚函数可以在基类中直接使用，而纯虚函数只能在子类中重写后才可以使用；
4.虚函数指针，在含有虚函数类的对象中，指向虚函数表，在运行时确定；
5.虚函数表：在程序只读数据段，存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建；
6.虚继承，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针；
7.虚基类表，不占用类对象的存储空间，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面，当虚继承的子类被当做父类继承时，虚基类指针也会被继承；



const：
1.修饰变量，该变量不可以被改变；
2.修饰指针，分为指向常量的指针和自身是常量的指针（常量指针）；
3.修饰引用，指向常量的引用，用于形参类型，即避免了拷贝，又避免了函数对值的修改；
4.修饰成员函数，说明该成员函数内不能修改成员变量；

static
1.修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在main之前分配内存，默认初始值为0
2.修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用，防止重复定义；
3.修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员；
4.修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员；

this指针
1.this指针隐含在每一个非静态成员函数中，指向调用该成员函数的类，调用成员函数都隐含的传递thi指针；
2.该指针为一个const指针,则指针所指向的类不可改变，即不能对这种对象的数据成员进行赋值操作；
3.this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &this）；


inline内联函数
1.相当于把内联函数里面的内容写在调用内联函数位置；
2.相当于不用执行进入函数的步骤，直接执行函数体；
3.相当于宏，却比宏多了类型检查，真正具有函数特性；
4.编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
5.注意在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数；
6.内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度，但是代码会膨胀，用空间换取时间；
7.虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联，（inline virtual）编译器知道所调用的对象是哪个类才可以使用（例如Base::func()）


volatile:
1.使用volatile 告诉编译器不应对这样的对象进行优化,每次访问时都必须从内存中取出值(没有时程序运行会直接从寄存器中取值)；
2.const volatile 定义变量时，可以规定变量只可读；
3.volatile 定义指针，指针可以改变，实际应该中共享内存时可以使用，指针会属于不同进程或者线程；

struct和class：
1.struct通常用于定义数据结构，class通常定义为抽象类；
2.struct默认继承方式为public，class默认继承方式为private；

union：
1，联合体（union）是一种节省空间的特殊的类；
2.一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值，当某个成员被赋值后其他成员变为未定义状态；
3.特点{
  1）默认访问控制符为 public；
  2）可以含有构造函数、析构函数；
  3）不能含有引用类型的成员；
  4）不能继承自其他类，不能作为基类；
  5）不能含有虚函数；
  6）匿名 union 在定义所在作用域可直接访问 union 成员；
  7）匿名 union 不能包含 protected 成员或 private 成员；
  8）全局匿名联合必须是静态（static）的；
}

explicit：
1.修饰构造函数时，防止构造函数隐式转换；
2.修饰转换函数时，可以防止隐式转换，但 按语境转换除外；

friend友元类和友元函数：
1.能访问私有成员；
2.友元关系不可传递；
3.友元关系的单向性；
4.【破坏封装性，没有特殊情况不要用】；














